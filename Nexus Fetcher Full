# new_gui_bot.py (Rewritten for iPhone-like UI)
import tkinter as tk
from tkinter import filedialog, scrolledtext, ttk
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.chrome.options import Options as ChromeOptions
import time
import re
import threading
import gspread
from google.oauth2.service_account import Credentials
from gspread.exceptions import WorksheetNotFound
from datetime import datetime
import csv
import psutil 

# --- Embedded Google Sheets Credentials ---
SERVICE_ACCOUNT_INFO = {
  "type": "service_account",
  "project_id": "nexusfetcher-sheets",
  "private_key_id": "",
  "private_key": "-----BEGIN PRIVATE KEY-----\\n-----END PRIVATE KEY-----\n",
  "client_email": "",
  "client_id": "111646858017421776639",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/sheets-bot%40nexusfetcher-sheets.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}


class Application(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master, bg="#f9f9f9")
        self.master = master
        self.stop_event = threading.Event()
        self.master.title("NexusFetcher")
        self.master.geometry("500x800")
        self.pack(fill=tk.BOTH, expand=True)
        
        # State management
        self.source_file_path = ""
        self.file_lines = []
        self.mc_numbers_list = []
        self.processed_mc_numbers = set()
        self.last_processed_index = -1
        self.total_records = 0
        self.start_time = 0
        self.processed_count = 0
        self.scraped_count = 0
        self.skipped_count = 0

        # State for system monitoring
        self.monitoring_on = threading.Event()
        
        self.setup_styles()
        self.create_widgets()
        self.master.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.start_monitoring()

    def setup_styles(self):
        style = ttk.Style()
        style.theme_create("iphone_theme", parent="default", settings={
            "TFrame": {"configure": {"background": "#f9f9f9"}},
            "TLabel": {"configure": {"background": "#f9f9f9", "font": ("SF Pro Display", 10)}},
            "TButton": {"configure": {"font": ("SF Pro Display", 12, "bold"), "foreground": "white", "background": "#007AFF", "borderwidth": 0, "padding": [10, 5], "relief": "flat"},
                        "map": {"background": [("active", "#005ecb")]}},
            "Card.TFrame": {"configure": {"background": "white", "relief": "solid", "borderwidth": 1, "bordercolor": "#e0e0e0", "padding": [15, 10], "borderradius": 10}},
            "TEntry": {"configure": {"fieldbackground": "#ffffff", "bordercolor": "#e0e0e0", "foreground": "#333333", "relief": "solid", "borderwidth": 1, "padding": [5, 5], "borderradius": 5}},
            "TCheckbutton": {"configure": {"background": "white", "font": ("SF Pro Display", 10)}},
            "TRadiobutton": {"configure": {"background": "#ffffff", "font": ("SF Pro Display", 10)}},
            "TNotebook": {"configure": {"padding": 0, "borderwidth": 0, "tabposition": "nw", "background": "#f9f9f9"}},
            "TNotebook.Tab": {"configure": {"padding": [15, 5], "font": ("SF Pro Display", 10, "bold"), "background": "#f0f0f0", "foreground": "#555555"},
                              "map": {"background": [("selected", "#ffffff")], "foreground": [("selected", "#007AFF")]}},
            "TProgressbar": {"configure": {"background": "#007AFF", "thickness": 10, "troughcolor": "#e0e0e0", "relief": "flat", "borderradius": 5}},
            "Treeview": {"configure": {"background": "white", "foreground": "#333333", "fieldbackground": "white", "font": ("SF Pro Display", 9), "relief": "flat"},
                         "map": {"background": [("selected", "#d9e8ff"), ("!active", "white")]}},
            "Treeview.Heading": {"configure": {"font": ("SF Pro Display", 9, "bold"), "background": "#f0f0f0", "foreground": "#333333"}}
        })
        style.theme_use("iphone_theme")
        style.configure("Rounded.TButton", relief="flat", borderwidth=0, borderradius=10)


    def create_widgets(self):
        # --- Main Header ---
        header_frame = ttk.Frame(self, style="TFrame")
        header_frame.pack(fill=tk.X, pady=(20, 10), padx=20)
        header = ttk.Label(header_frame, text="NexusFetcher", font=("SF Pro Display", 24, "bold"), style="TLabel")
        header.pack(side=tk.LEFT)
        self.browser_status_var = tk.StringVar(value="")
        self.browser_status_label = ttk.Label(header_frame, textvariable=self.browser_status_var, font=("SF Pro Display", 9), foreground="#00C853")
        self.browser_status_label.pack(side=tk.RIGHT, pady=(5,0))

        # --- Automation Controls Card ---
        input_card = ttk.Frame(self, style="Card.TFrame")
        input_card.pack(fill=tk.X, padx=20, pady=10)
        
        ttk.Label(input_card, text="Automation Controls", font=("SF Pro Display", 14, "bold"), style="TLabel").pack(fill=tk.X, pady=(0, 10))
        
        url_frame = ttk.Frame(input_card, style="TFrame")
        url_frame.pack(fill=tk.X, pady=5)
        ttk.Label(url_frame, text="Website URL").pack(side=tk.LEFT, padx=(0,10))
        self.url_entry = ttk.Entry(url_frame, font=("SF Pro Display", 10), style="TEntry")
        self.url_entry.insert(0, "https://safer.fmcsa.dot.gov/CompanySnapshot.aspx")
        self.url_entry.pack(side=tk.RIGHT, fill=tk.X, expand=True)

        file_frame = ttk.Frame(input_card, style="TFrame")
        file_frame.pack(fill=tk.X, pady=5)
        ttk.Label(file_frame, text="Numbers File").pack(side=tk.LEFT, padx=(0,10))
        self.file_path_entry = ttk.Entry(file_frame, state="readonly", font=("SF Pro Display", 10), style="TEntry")
        self.file_path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.browse_button = ttk.Button(file_frame, text="Browse", command=self.browse_data_file, style='Rounded.TButton')
        self.browse_button.pack(side=tk.RIGHT, padx=(10,0))
        
        # --- Configuration Card ---
        config_card = ttk.Frame(self, style="Card.TFrame")
        config_card.pack(fill=tk.X, padx=20, pady=10)
        
        ttk.Label(config_card, text="Configuration", font=("SF Pro Display", 14, "bold"), style="TLabel").pack(fill=tk.X, pady=(0, 10))

        gsheet_frame = ttk.Frame(config_card, style="TFrame")
        gsheet_frame.pack(fill=tk.X, pady=5)
        ttk.Label(gsheet_frame, text="Spreadsheet Name").pack(side=tk.LEFT, padx=(0,10))
        self.gsheet_name_entry = ttk.Entry(gsheet_frame, font=("SF Pro Display", 10), style="TEntry")
        self.gsheet_name_entry.pack(side=tk.RIGHT, fill=tk.X, expand=True)
        
        # Optional Data - Segmented Control style
        optional_frame = ttk.Frame(config_card, style="TFrame")
        optional_frame.pack(fill=tk.X, pady=5)
        ttk.Label(optional_frame, text="Optional Data:").pack(side=tk.LEFT)
        self.scrape_physical_var = tk.BooleanVar(value=False)
        self.scrape_mailing_var = tk.BooleanVar(value=False)
        
        self.physical_check = ttk.Checkbutton(optional_frame, text="Physical Address", variable=self.scrape_physical_var)
        self.physical_check.pack(side=tk.LEFT, padx=5)
        self.mailing_check = ttk.Checkbutton(optional_frame, text="Mailing Address", variable=self.scrape_mailing_var)
        self.mailing_check.pack(side=tk.LEFT, padx=5)

        # Advanced Options
        adv_frame = ttk.Frame(config_card, style="TFrame")
        adv_frame.pack(fill=tk.X, pady=5)
        self.headless_var = tk.BooleanVar(value=True)
        self.headless_check = ttk.Checkbutton(adv_frame, text="Run Headless", variable=self.headless_var)
        self.headless_check.pack(side=tk.LEFT, padx=5)
        self.remove_processed_var = tk.BooleanVar(value=False)
        self.remove_processed_check = ttk.Checkbutton(adv_frame, text="Remove processed", variable=self.remove_processed_var)
        self.remove_processed_check.pack(side=tk.LEFT, padx=5)


        # --- Action Buttons ---
        button_frame = ttk.Frame(self, style="TFrame")
        button_frame.pack(fill=tk.X, padx=20, pady=(10, 5))
        self.start_button = ttk.Button(button_frame, text="Start / Resume", command=self.start_bot, style='Rounded.TButton')
        self.start_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        self.stop_button = ttk.Button(button_frame, text="Stop", command=self.stop_bot, style='Rounded.TButton')
        self.stop_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.export_button = ttk.Button(button_frame, text="Export", command=self.export_to_csv, style='Rounded.TButton')
        self.export_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.clear_button = ttk.Button(button_frame, text="Reset", command=self.clear_data, style='Rounded.TButton')
        self.clear_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5,0))

        # --- Live Progress Card ---
        progress_card = ttk.Frame(self, style="Card.TFrame")
        progress_card.pack(fill=tk.X, padx=20, pady=5)
        
        self.current_status_var = tk.StringVar(value="Status: Ready")
        ttk.Label(progress_card, textvariable=self.current_status_var, font=("SF Pro Display", 12, "bold")).pack(fill=tk.X)
        
        self.progressbar = ttk.Progressbar(progress_card)
        self.progressbar.pack(fill=tk.X, pady=(10, 5))

        stats_frame = ttk.Frame(progress_card, style="TFrame")
        stats_frame.pack(fill=tk.X, pady=5)
        self.processed_var = tk.StringVar(value="Processed: 0")
        self.scraped_var = tk.StringVar(value="Scraped: 0")
        self.skipped_var = tk.StringVar(value="Skipped: 0")
        self.eta_var = tk.StringVar(value="ETA: --")
        
        ttk.Label(stats_frame, textvariable=self.processed_var, font=("SF Pro Display", 10, "bold")).pack(side=tk.LEFT)
        ttk.Label(stats_frame, textvariable=self.scraped_var, font=("SF Pro Display", 10, "bold")).pack(side=tk.LEFT, padx=10)
        ttk.Label(stats_frame, textvariable=self.skipped_var, font=("SF Pro Display", 10, "bold")).pack(side=tk.LEFT, padx=10)
        ttk.Label(stats_frame, textvariable=self.eta_var, font=("SF Pro Display", 10)).pack(side=tk.RIGHT)

        # --- Data Display Tabs ---
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        self.data_frame = ttk.Frame(self.notebook, style="TFrame")
        self.log_frame = ttk.Frame(self.notebook, style="TFrame")
        self.notebook.add(self.data_frame, text="Extracted Data")
        self.notebook.add(self.log_frame, text="Console Log")

        # Data Treeview
        columns = ('mc_number', 'name', 'email', 'phone', 'physical', 'mailing')
        self.tree = ttk.Treeview(self.data_frame, columns=columns, show='headings', style='Treeview')
        self.tree.heading('mc_number', text='Number'); self.tree.heading('name', text='Name'); self.tree.heading('email', text='Email')
        self.tree.heading('phone', text='Phone'); self.tree.heading('physical', text='Physical'); self.tree.heading('mailing', text='Mailing')
        
        self.tree.column('mc_number', width=80, anchor='center'); self.tree.column('name', width=100); self.tree.column('email', width=120)
        self.tree.column('phone', width=80); self.tree.column('physical', width=100); self.tree.column('mailing', width=100)
        
        vsb = ttk.Scrollbar(self.data_frame, orient="vertical", command=self.tree.yview)
        vsb.pack(side='right', fill='y')
        self.tree.pack(side='left', fill='both', expand=True)
        self.tree.configure(yscrollcommand=vsb.set)

        # Console Log
        self.log_text = scrolledtext.ScrolledText(self.log_frame, wrap=tk.WORD, state=tk.DISABLED, font=("SF Mono", 9), background="#333333", foreground="#ffffff", borderwidth=0, relief="flat", highlightthickness=0)
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Footer
        footer_frame = ttk.Frame(self, style="TFrame")
        footer_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(10, 5))
        ttk.Label(footer_frame, text="Copyright reserved by Muneeb", font=('SF Pro Display', 8), anchor="center").pack(side=tk.BOTTOM, fill=tk.X)
        
        # Resource monitoring labels and progress bars
        # These were previously missing 'self.' assignments
        self.ram_var = tk.StringVar(value="App RAM: -- MB")
        self.cpu_var = tk.StringVar(value="App CPU: -- %")
        self.net_var = tk.StringVar(value="Network: ↓ 0 B/s | ↑ 0 B/s")

        self.resource_label = ttk.Label(footer_frame, textvariable=self.ram_var, font=('SF Pro Display', 8), anchor="center")
        self.resource_label.pack(side=tk.BOTTOM, fill=tk.X, pady=2)

        # Creating separate frames for progress bars to control their layout
        resource_progress_frame = ttk.Frame(footer_frame, style="TFrame")
        resource_progress_frame.pack(fill=tk.X, pady=(0, 5))
        resource_progress_frame.columnconfigure(0, weight=1)
        resource_progress_frame.columnconfigure(1, weight=1)

        ttk.Label(resource_progress_frame, textvariable=self.cpu_var, font=('SF Pro Display', 8)).grid(row=0, column=0, sticky="w", padx=5)
        self.cpu_progress = ttk.Progressbar(resource_progress_frame, length=100, mode='determinate')
        self.cpu_progress.grid(row=0, column=1, sticky="ew", padx=5)

        ttk.Label(resource_progress_frame, textvariable=self.ram_var, font=('SF Pro Display', 8)).grid(row=1, column=0, sticky="w", padx=5)
        self.ram_progress = ttk.Progressbar(resource_progress_frame, length=100, mode='determinate')
        self.ram_progress.grid(row=1, column=1, sticky="ew", padx=5)

        ttk.Label(footer_frame, textvariable=self.net_var, font=('SF Pro Display', 8), anchor="center").pack(side=tk.BOTTOM, fill=tk.X, pady=2)


    def on_closing(self):
        self.stop_event.set()
        self.monitoring_on.clear()
        self.master.destroy()

    def start_monitoring(self):
        self.monitoring_on.set()
        monitor_thread = threading.Thread(target=self.update_system_stats, daemon=True)
        monitor_thread.start()

    def format_bytes(self, size):
        power = 1024
        n = 0
        power_labels = {0: '', 1: 'K', 2: 'M', 3: 'G', 4: 'T'}
        while size > power and n < len(power_labels):
            size /= power
            n += 1
        return f"{size:.1f}{power_labels[n]}B/s"

    def update_system_stats(self):
        process = psutil.Process()
        last_net_io = psutil.net_io_counters()
        last_time = time.time()
        while self.monitoring_on.is_set():
            try:
                cpu_percent = process.cpu_percent(interval=1)
                ram_info = process.memory_info()
                ram_mb = ram_info.rss / (1024 * 1024)
                
                current_net_io = psutil.net_io_counters()
                current_time = time.time()
                
                elapsed_time = current_time - last_time
                if elapsed_time > 0:
                    sent_speed = (current_net_io.bytes_sent - last_net_io.bytes_sent) / elapsed_time
                    recv_speed = (current_net_io.bytes_recv - last_net_io.bytes_recv) / elapsed_time
                else:
                    sent_speed, recv_speed = 0, 0

                last_net_io = current_net_io
                last_time = current_time

                # Update the StringVar and Progressbar values
                self.master.after(0, lambda: self.cpu_var.set(f"App CPU: {cpu_percent:.1f} %"))
                self.master.after(0, lambda: self.ram_var.set(f"App RAM: {ram_mb:.1f} MB"))
                self.master.after(0, lambda: self.cpu_progress.config(value=cpu_percent))
                self.master.after(0, lambda: self.ram_progress.config(value=ram_mb))
                self.master.after(0, lambda: self.net_var.set(f"Network: ↓ {self.format_bytes(recv_speed)} | ↑ {self.format_bytes(sent_speed)}"))
                
            except psutil.NoSuchProcess:
                self.monitoring_on.clear()
                self.master.after(0, lambda: self.resource_label.config(text="Monitoring stopped"))
                break

    def clear_data(self):
        self.update_status("Clearing all data and resetting progress...")
        self.stop_event.set()
        self.tree.delete(*self.tree.get_children())
        self.mc_numbers_list = []
        self.file_lines = []
        self.source_file_path = ""
        self.processed_mc_numbers.clear()
        self.last_processed_index = -1
        self.processed_count, self.scraped_count, self.skipped_count = 0, 0, 0
        self.processed_var.set("Processed: 0")
        self.scraped_var.set("Scraped: 0")
        self.skipped_var.set("Skipped: 0")
        self.progressbar['value'] = 0
        self.eta_var.set("ETA: --")
        self.file_path_entry.config(state="normal"); self.file_path_entry.delete(0, tk.END); self.file_path_entry.config(state="readonly")
        self.update_status("Reset complete. Ready to start a new run.")
        self.export_button.config(state="disabled")

    def export_to_csv(self):
        if not self.tree.get_children():
            self.update_status("No data to export.")
            return
        file_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv"), ("All files", "*.*")], title="Save Scraped Data")
        if not file_path: return
        try:
            with open(file_path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["MC Number", "Name", "Email", "Phone", "Physical Address", "Mailing Address"])
                for child in self.tree.get_children():
                    writer.writerow(self.tree.item(child)['values'])
            self.update_status(f"Successfully exported data to {file_path}")
        except Exception as e:
            self.update_status(f"Error exporting to CSV: {e}")

    def update_stats(self, stat_type, current_index):
        if stat_type == 'processed': self.processed_count += 1
        elif stat_type == 'scraped': self.scraped_count += 1
        elif stat_type == 'skipped': self.skipped_count += 1
        
        self.last_processed_index = current_index
        if current_index < len(self.mc_numbers_list):
            mc_number = self.mc_numbers_list[current_index]
            self.processed_mc_numbers.add(mc_number)

        self.processed_var.set(f"Processed: {self.processed_count}")
        self.scraped_var.set(f"Scraped: {self.scraped_count}")
        self.skipped_var.set(f"Skipped: {self.skipped_count}")
        self.progressbar['value'] = self.processed_count
        self._update_eta()

    def _update_eta(self):
        if self.processed_count > 1 and self.processed_count < self.total_records:
            elapsed_time = time.time() - self.start_time
            time_per_item = elapsed_time / self.processed_count
            remaining_items = self.total_records - self.processed_count
            eta_seconds = int(time_per_item * remaining_items)
            mins, secs = divmod(eta_seconds, 60)
            self.eta_var.set(f"ETA: {mins}m {secs}s")
        elif self.processed_count == self.total_records:
            self.eta_var.set("ETA: Complete")

    def add_data_to_table(self, mc_number, name, email, phone, physical, mailing):
        self.after(0, lambda: self.tree.insert('', tk.END, values=(mc_number, name, email, phone, physical, mailing)))

    def browse_data_file(self):
        file_path = filedialog.askopenfilename(title="Select a Text File", filetypes=(("Text files", "*.txt"), ("All files", "*.*")))
        if file_path:
            self.source_file_path = file_path
            self.file_path_entry.config(state="normal"); self.file_path_entry.delete(0, tk.END); self.file_path_entry.insert(0, file_path); self.file_path_entry.config(state="readonly")
            self.clear_data()
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    self.file_lines = f.readlines()
                
                content = "".join(self.file_lines)
                self.mc_numbers_list = re.findall(r'MC-(\d+)', content)
                self.total_records = len(self.mc_numbers_list)

                if self.total_records == 0:
                    self.update_status("Error: No MC numbers found in file.")
                    self.mc_numbers_list = []
                else:
                    self.update_status(f"Loaded {self.total_records} MC numbers. Ready.")
                    self.progressbar['maximum'] = self.total_records
            except Exception as e:
                self.update_status(f"Error reading file: {e}")

    def update_status(self, message):
        timestamp = datetime.now().strftime("[%H:%M:%S] ")
        full_message = timestamp + message.strip()
        self.after(0, lambda: self._update_status_log(full_message))

    def _update_status_log(self, message):
        self.current_status_var.set(f"Status: {message.split('] ')[1]}")
        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)

    def set_ui_state_running(self):
        self.start_button.config(state="disabled")
        self.stop_button.config(state="normal")
        self.export_button.config(state="disabled")
        self.clear_button.config(state="disabled")
        self.physical_check.config(state="disabled")
        self.mailing_check.config(state="disabled")
        self.browse_button.config(state="disabled")
        self.headless_check.config(state="disabled")
        self.remove_processed_check.config(state="disabled")
        self.browser_status_var.set("● Browser Active")
        self.stop_event.clear()


    def set_ui_state_finished(self):
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        self.clear_button.config(state="normal")
        self.physical_check.config(state="normal")
        self.mailing_check.config(state="normal")
        self.browse_button.config(state="normal")
        self.headless_check.config(state="normal")
        self.remove_processed_check.config(state="normal")
        self.browser_status_var.set("")
        if self.tree.get_children():
            self.export_button.config(state="normal")

    def start_bot(self):
        if not self.mc_numbers_list:
            self.update_status("Error: No data file loaded.")
            return
        
        self.start_time = time.time()
        
        self.set_ui_state_running()

        bot_thread = threading.Thread(target=self.run_bot_and_update_gui, daemon=True)
        bot_thread.start()

    def stop_bot(self):
        self.update_status("Stop button pressed. Halting...")
        self.stop_event.set()
        self.stop_button.config(state="disabled")

    def run_bot_and_update_gui(self):
        try:
            self.run_scraping_process()
        finally:
            self.after(0, self.finalize_run)
    
    def finalize_run(self):
        self.set_ui_state_finished()
        
        if self.remove_processed_var.get() and self.source_file_path:
            try:
                self.update_status("Updating source file...")
                remaining_lines = []
                for line in self.file_lines:
                    match = re.search(r'MC-(\d+)', line)
                    if match:
                        if match.group(1) not in self.processed_mc_numbers:
                            remaining_lines.append(line)
                    else:
                        remaining_lines.append(line)

                with open(self.source_file_path, 'w', encoding='utf-8') as f:
                    f.writelines(remaining_lines)
                self.update_status("Source file updated successfully.")
            except Exception as e:
                self.update_status(f"Error updating source file: {e}")

        if not self.stop_event.is_set():
            self.update_status("Finished")
            self.last_processed_index = -1 
            self.mc_numbers_list = []
        else:
            self.update_status("Stopped by user")

    def find_and_click_with_fallbacks(self, driver, wait, selectors):
        for i, selector in enumerate(selectors):
            try:
                element = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
                driver.execute_script("arguments[0].click();", element)
                time.sleep(0.5) 
                return True
            except (TimeoutException, NoSuchElementException):
                self.update_status(f"Selector attempt {i+1} failed. Trying next...")
                continue
        return False

    def run_scraping_process(self):
        target_url = self.url_entry.get()
        start_index = self.last_processed_index + 1
        scrape_options = {'physical': self.scrape_physical_var.get(), 'mailing': self.scrape_mailing_var.get()}
        spreadsheet_name = self.gsheet_name_entry.get()
        run_headless = self.headless_var.get()

        worksheet = None
        if spreadsheet_name:
            try:
                self.update_status("Authenticating with Google Sheets...")
                scopes = ["https://www.googleapis.com/auth/spreadsheets", "https://www.googleapis.com/auth/drive"]
                creds = Credentials.from_service_account_info(SERVICE_ACCOUNT_INFO, scopes=scopes)
                client = gspread.authorize(creds)
                sheet = client.open(spreadsheet_name)
                worksheet = sheet.worksheets()[0]
                self.update_status(f"Opened worksheet: '{worksheet.title}'.")
                if not worksheet.get('A1'):
                    headers = ["MC Number", "Name", "Email", "Phone", "Physical Address", "Mailing Address", "Timestamp"]
                    worksheet.append_row(headers)
                    worksheet.format('A1:G1', {'textFormat': {'bold': True}})
            except Exception as e:
                self.update_status(f"!!! Google Sheets Error: {e}")
                self.add_data_to_table("ERROR", "Google Sheets Failed", str(e), "", "","")

        
        self.update_status("Initializing web driver...")
        try:
            chrome_options = ChromeOptions()
            if run_headless:
                chrome_options.add_argument("--headless")
                chrome_options.add_argument("--window-size=1920,1080")
            driver = webdriver.Chrome(options=chrome_options)
            wait = WebDriverWait(driver, 15)
        except Exception as e:
            self.update_status(f"Error initializing WebDriver: {e}")
            return

        try:
            for i in range(start_index, len(self.mc_numbers_list)):
                if self.stop_event.is_set():
                    self.update_status("Stop signal received.")
                    break
                
                number = self.mc_numbers_list[i]
                self.update_stats('processed', i)
                self.update_status(f"Processing {i + 1}/{len(self.mc_numbers_list)}: MC-{number}")

                try:
                    driver.get(target_url)
                    if driver.find_elements(By.CSS_SELECTOR, 'body > center > h1'):
                        self.update_status("!!! ERROR: Connection issue (VPN?).")
                        return

                    RADIO_BUTTON_SELECTOR = '#\\32'
                    INPUT_FIELD_SELECTOR = '#\\34'
                    SEARCH_BUTTON_SELECTOR = 'body > form > p > table > tbody > tr:nth-child(4) > td > input[type=SUBMIT]'
                    
                    wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, RADIO_BUTTON_SELECTOR))).click()
                    input_field = driver.find_element(By.CSS_SELECTOR, INPUT_FIELD_SELECTOR)
                    input_field.clear()
                    input_field.send_keys(number)
                    driver.find_element(By.CSS_SELECTOR, SEARCH_BUTTON_SELECTOR).click()

                    no_results_selector = 'body > table > tbody > tr:nth-child(2) > td > p > font > b > i'
                    try:
                        WebDriverWait(driver, 2).until(EC.presence_of_element_located((By.CSS_SELECTOR, no_results_selector)))
                        self.update_status(f"No records found for MC-{number}. Skipping.")
                        self.update_stats('skipped', i)
                        continue
                    except TimeoutException:
                        pass

                    RESULTS_LINK_SELECTOR = 'body > p > table > tbody > tr:nth-child(2) > td > table > tbody > tr:nth-child(2) > td > table:nth-child(1) > tbody > tr:nth-child(3) > td > table > tbody > tr:nth-child(2) > td > table > tbody > tr:nth-child(3) > td:nth-child(2) > font > a'
                    
                    if not self.find_and_click_with_fallbacks(driver, wait, [RESULTS_LINK_SELECTOR]):
                        self.update_status(f"Could not find results link for MC-{number}. Skipping.")
                        self.update_stats('skipped', i)
                        continue
                    
                    CARRIER_REG_SELECTORS = ['#CarrierRegistration > a:nth-child(2)', 'a[href*="CarrierRegistration"]']
                    if not self.find_and_click_with_fallbacks(driver, wait, CARRIER_REG_SELECTORS):
                        self.update_status(f"Could not find Carrier Details link for MC-{number}. Skipping.")
                        self.update_stats('skipped', i)
                        continue

                    DETAILS_CONTAINER_SELECTOR = '#regBox'
                    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, DETAILS_CONTAINER_SELECTOR)))

                    NAME_SELECTOR = '#regBox > ul.col1 > li:nth-child(1) > span'
                    PHONE_SELECTOR = '#regBox > ul.col1 > li:nth-child(5) > span'
                    EMAIL_SELECTOR = '#regBox > ul.col1 > li:nth-child(7) > span'
                    PHYSICAL_ADDRESS_SELECTOR = '#regBox > ul.col1 > li:nth-child(3) > span'
                    MAILING_ADDRESS_SELECTOR = '#regBox > ul.col1 > li:nth-child(4) > span'
                    
                    name = driver.find_element(By.CSS_SELECTOR, NAME_SELECTOR).text if driver.find_elements(By.CSS_SELECTOR, NAME_SELECTOR) else "N/A"
                    phone = driver.find_element(By.CSS_SELECTOR, PHONE_SELECTOR).text if driver.find_elements(By.CSS_SELECTOR, PHONE_SELECTOR) else "N/A"
                    email = driver.find_element(By.CSS_SELECTOR, EMAIL_SELECTOR).text if driver.find_elements(By.CSS_SELECTOR, EMAIL_SELECTOR) else "N/A"
                    
                    physical_address = "Not Scraped"
                    if scrape_options['physical']:
                        physical_address = driver.find_element(By.CSS_SELECTOR, PHYSICAL_ADDRESS_SELECTOR).text if driver.find_elements(By.CSS_SELECTOR, PHYSICAL_ADDRESS_SELECTOR) else "N/A"

                    mailing_address = "Not Scraped"
                    if scrape_options['mailing']:
                        mailing_address = driver.find_element(By.CSS_SELECTOR, MAILING_ADDRESS_SELECTOR).text if driver.find_elements(By.CSS_SELECTOR, MAILING_ADDRESS_SELECTOR) else "N/A"
                    
                    self.add_data_to_table(f"MC-{number}", name, email, phone, physical_address, mailing_address)
                    self.update_stats('scraped', i)

                    if worksheet:
                        try:
                            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                            worksheet.append_row([f"MC-{number}", name, email, phone, physical_address, mailing_address, timestamp], value_input_option='USER_ENTERED')
                            body = {"requests": [{"autoResizeDimensions": {"dimensions": {"sheetId": worksheet.id, "dimension": "COLUMNS", "startIndex": 0, "endIndex": 7}}}]}
                            worksheet.spreadsheet.batch_update(body)
                        except Exception as e:
                            self.update_status(f"!!! GSheets Append Error: {e}")
                    time.sleep(1)
                except Exception as e:
                    self.update_status(f"Error on MC-{number}: {e}. Skipping.")
                    self.update_stats('skipped', i)
                    continue
        except Exception as e:
            self.update_status(f"A critical error occurred: {e}")
        finally:
            self.update_status("Closing the browser.")
            if 'driver' in locals() and driver:
                driver.quit()

if __name__ == "__main__":
    root = tk.Tk()
    app = Application(master=root)
    app.mainloop()
